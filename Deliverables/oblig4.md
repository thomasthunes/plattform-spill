# Obligatorisk oppgave 4 - Navn på prosjekt: *Game*
**Team**: *Scrumbois* (Gruppe 3)  
**Gruppemedlemmer:**  
 - Thomas Thunes
 - Karl Martin Helset
 - Magnus Brodtkorb
 - Jonas Holgersen
 - Jon Kvinnsland  

**Prosjektbeskrivelse:** I dette spillet styrer du en spiller med enten piltaster eller ASWD, og bruker space til å la spilleren hoppe. Målet er å ikke dø, det vil si å ikke miste så mye liv at liv blir 0. Spilleren mister liv når den er i kontakt med en fiende, men kan drepe fienden ved å hoppe oppå den. Spilleren kan også plukke opp liv ved å trykke på "P" når den står på et liv-objekt (en rød sekk med et hvitt kors på).  

**Beskrivelse av spillet:** *Hvem er spiller, fiender, mål etc. Legge denne også inn på README.*

## Innholdsfortegnelse  
[[_TOC_]]  

# 1. Team og prosjekt
I denne delen av oppgaven vil vi gjennomgå (1) møtereferater og (2) en oppsummering av team og prosjekt.  

## 1.1 Møtereferater  
Møtereferatene oppsummerer hva som har blitt disuktert på de ulike møtene, eventuelle avgjørelser som er tatt og hvilke arbeidsoppgaver vi har fordelt frem til neste møte. Under følger det møtereferater fra den forrige innleveringen frem til nå. Alle møtereferatene gjennom hele prosjektet er også oppsummert i et eget dokument [her](https://git.app.uib.no/scrumbois/plattform-spill/-/blob/master/Deliverables/M%C3%B8tereferater.md).  

### 1.1.1 Møte 1
**Dato:** 19.04   

**Deltakere:** Alle  

**Diskusjon:** På dette møtet hadde vi en samtale der vi kartla hva som blir de viktigste leveransene ved prosjektet frem mot den siste innleveringen (29.04). Her identifiserte vi at vi trenger å få implementert ferdig funksjonalitet for multiplayer, legge inn nye brukerhistorier og ferdigstille den siste rapporten. Vi identifiserte også mindre endringer slik som å legge til et ekstra spillebrett/level når spilleren er ferdig med det første og legge til lydeffekter når spilleren hopper.  

**Avgjørelser:** Vi tok en avgjørelse på å ha lydeffekt når spilleren hopper og at vi skulle legge til et ekstra level i spillet.  

**Arbeidsoppgaver til neste møte:** Thomas jobber med implementasjonen av multiplayer, Karl jobber med implementasjonen av lydeffekt for hopping, Jonas jobber videre med testing, Magnus starter på de nye brukerhistoriene og Jon starter på rapporten til siste innlevering.   

### 1.1.2 Møte 2
**Dato:** 26.04  

**Deltakere:** Alle  

**Diskusjon:** På dette møtet diskuterte vi hva som er de resterende arbeidsoppgavene som må bli gjort til innleveringen på fredag 29.04. Her fant vi ut at å sikre god testdekning var det viktigste som gjenstår, og vi ble dermed enige om å legge inn flere ressurser på dette for å komme i mål. Vi diskuterte også hvordan vi ønsket at muligheten for å resize spillevinduet skulle være, da vi ser at dette kan gi utfordringer på ulike skjermstørrelser. Etter mye testing og feiling satte vi spillevinduet til å være lik skjermstørrelsen, men uten muligheten til å kunne ta fullskjerm. Dette fordi vi merket at dersom vi resizet størrelsen på spilleskjermen etter at spillet hadde startet så flyttet knappene på meny-skjermen på seg slik at det ble vanskeligere å starte spillet. Videre hadde vi også en retrospektiv diskusjon på hvordan vi syntes at prosjektet har vært, hva vi har lært og hva vi ville gjort annereledes om vi hadde startet på nytt. Denne diskusjonen er oppsummert i [1.2.8 Retrospektiv vurdering av hele prosjektet](#128-retrospektiv-vurdering-av-hele-prosjektet). Hovedpunktene er at vi syntes prosjektet har vært en lærerik prosess der vi har lært mer om hvordan arbeide sammen med andre i et utviklingsprosjekt, i tillegg til at alle har fått fordypet seg i hver sin respekive rolle og bli flinkere på å håndtere arbeidsoppgavene knyttet til denne rollen.  

**Avgjørelser:** På dette møtet blir vi enige om å legge mye ressurser inn på å sikre god testdekning frem mot siste innlevering. Det innebærer at 3/5 gruppemedlemmer jobber med testing (Jonas, Magnus og Jon). Vi tok også en beslutning på at det ikke skal være mulig å ta fullskjerm på spillet, men at skjermstørrelsen på spillet skal være lik den faktiske skjermstørrelsen.   

**Arbeidsoppgaver til neste møte:** Thomas rydder opp i koden, fjerner ubrukte funksjoner og skriver javadocs. Karl forbedrer de eksisterende funksjonene. Jonas, Magnus og Jon jobber med tester. Jon jobber også med å ferdigstille rapporten.  

## 1.2 Oppsummering av team og prosjekt  
I denne delen av oppgaven oppsummerer vi hvordan arbeidet i gruppen har vært og reflekterer over utviklingen i vårt prosjekt.  
### 1.2.1 Roller  
Fra forrige innlevering (08.04) har vi omtrent det samme behovet for rollefordeling. Vi velger å fortsette med de samme rollene da vi drar godt nytte av spesialiseringen som hver enkelt gruppemedlem har oppnådd i hver sin respektive rolle. Målet er å sikre god kvalitet og effektivitet i arbeidet, og dette mener vi at vi oppnår med denne rollefordelingen. Dermed er det også lite endringer når det gjelder hva de ulike rollene faktisk innebærer for oss. Etter det siste møte vi hadde (26.04) har vi imidlertid kanalisert ressrusene slik at 3 gruppemedlemmer jobber med tester. Dette er frem til nå det største avviket vi har hatt når det gjelder rollefordeling. Rollefordelingen for hvert enkelt gruppemedlem er oppsummert som følgende:  

Thomas har merket at sin rolle som teamleder innebærer at fortsatt må holde god oversikt på utviklingsprosessen, og spesielt hva som mangler i listen på MVP. Dette merker han også er ekstra krevende fram mot siste innlevering, da siste innlevering krever at alt med prosjektet er ferdig. Dermed må han ha en komplett oversikt på prosjketet.  

Magnus har merket at sin rolle som prosjektansvarlig innebærer at han må være fokusert på hvordan ressursfordelingen skal være fram mot siste innlevering. Dette gjelder spesielt må ettersom mange arbeidsoppgaver begynner å bli ferdige. Dermed må roller og tilhørende arbeidsoppgaver omfordeles slik at alle har noe å jobbe med. Dette gjelder spesielt på testing der to ekstra ressurser (gruppemedlemmer) er satt inn på dette.  

Karl har merket at sin rolle som Scrum Master innebærer at han må ha en god oversikt på prosessene i Scrum rammeverket. Dette gjelder også spesielt for siste innlevering der vi nå skal reflektere over hva vi mener har fungert bra og hva vi ville ha endret på om vi startet på nytt. Her merker Karl at han som Scrum Master har mange innspill og refleksjoner som han må bidra med i denne diskusjonen (se [1.2.8 Retrospektiv vurdering av hele prosjektet](#128-retrospektiv-vurdering-av-hele-prosjektet)).

Jonas har merket at sin rolle som testansvarlig innebærer at han må fortsette å holde god oversikt på innholdet i koden for å sikre god testdekning. Her merker han at rollen som testansvarlig blir ekstra krevende etterhvert som kompleksisteten i spillet blir større. Dette fordi det kreves mer omfattende testing for å sørge for at hele prosjektet har god testdekning. På bakgrunn av dette har dermed Jonas bedt om ekstra ressurser på testdekningen, altså hjelp fra de andre gruppemedlemmene for at vi skal komme i mål på god testdekning.  

Jon har merket at sin rolle som kundekontakt innebærer at han må fortsette å oppretteholde kommunikasjon med kunden for å sikre at det endelige prosjektleveransen imøtekommer de krav og forventninger som kunden måtte ha. Jon merker dermed at det er viktig at han sørger for at informasjon og tilbakemeldinger fra kunden blir formidlet til de rette rollene i gruppen, slik at hver enkelt gruppemedlem er inneforstått med hva de må gjøre for å tilfredsstille kunden.  

### 1.2.2 Erfaringer og valg  
Drøftelsene vi har gjort med tanke på erfaringer og valg tilsvarer de samme som ved forrige innlevering. Etter å ha holdt på med prosjektet over en lang periode merker vi nå at vi er ferdig med å gjøre oss de viktigste erfaringer og valg, og at vi nå begynner å bli mer erfarne i prosjektet. Dermed har vi ikke gjort oss noen vesentlige nye erfaringer fra sist, men vi merker oss likevel følgende:  

**Erfaringer team:** Når det gjelder erfaringer vi har gjort oss i teamet så er vi fornøyde med rollefordelingen. Vi har også merket oss frem mot siste innlevering nå at vi har hatt noe behov for at flere bistår på en gitt rolle, slik som testing. Dette merker vi har gitt god effekt, da sterk kooridnering på en spesifikk rolle gjør at vi kan ta unna disse arbeidsoppgavene effektivt og med god kvalitet. Her merker vi for eksempel at når flere bidrar med sine tanker og idéer på testing blir kvaliteten den samlede leveransen bedre. Ellers merker vi oss at erfaringene vi har gjort oss tidligere i prosjektet også er gjeldene nå (jf. oblig 1, 2 og 3).  

**Erfaringer prosjektmetodikk:** Når det gjelder erfaringer relatert til prosjektmetodikk har vi merket fra forrige innlevering at det kan være fordelaktig å avvike fra Scrum rammeverket i enkelte tilfeller. Dette gjelder spesifikt for hvordan vi har avviket fra rollefordelingen for å kanalisere flere ressurser på testing. Merk at dette er imidlertid over en kortere periode, og at vi likevel strekker oss tilbake til den opprinnelige rollefordelingen etter at arbeidsoppgavene er utført.  

**Valg underveis:** Her gjør vi oss det samme refleksjoner som tidligere, nemlig at reflekterte diskusjoner over valgalternativer og mulige konsekvenser har ført til at vi er samstemte i de valgene vi tar. Dersom et valg skulle vise seg i etterkant å ikke være optimalt har vi tatt en diskusjon på dette for å finne ut hvordan vi kan ta bedre valg. Dette gjelder for eksempel valget om skjermstørrelse der vi tidligere hadde valgt å ha mulighet til å velge fullskjerm, men som vi i etterkant endret til kun være en fast skjermstørrelse. Dette førte til at vi ikke lenger fikk problemer med plassering av knappene på meny-skjermen slik som vi tidligere fikk etter å ha resizet skjermen til fullskjerm. Av dette lærte vi dermed at vi drar nytte av å ha gode diskusjoner underveis på valgene vi tar, og at det også kan være hensiktsmessig å ta opp enkelte diskusjoner på nytt for å forbedre produktkvaliteten.  

### 1.2.3 Gruppedynamikk
Når det gjelder våre erfaringer knyttet til gruppedynamikken merker vi som tidligere at Scrum rammeverket legger godt til rette for en god gruppedynamikk. Dette gjelder blant annet de ukentlige Scrum-møtene der vi møtes for å diskutere progresjon i prosjektet og hvilke endringer som eventuelt må gjøres. Gjennom vårt project board og sprinter klarer vi også å oppnå en klar forventning til hva hver enkelt skal jobbe med, slik at det blir enklere for alle å holde oversikt på utviklingen i prosjektet. Vi har også merket at vi har hatt god nok gruppedynamikk til å kunne samarbeide om arbeidsoppgaver knyttet til en spesifikk rolle, slik som for eksempel testing.  

### 1.2.4 Kommunikasjon
Når det gjelder våre erfaringer knyttet til kommunikasjon i gruppen så merker vi oss de samme erfaringer som tidligere. Dette gjelder blant annet at vi opprettholder god kommunikasjon utenom gruppemøtene via våre informasjonskanaler Messenger og Discord. På denne måten blir det enklere for alle å holde oversikt på framgangen i prosjektet også utenfor gruppemøtene. På gruppemøtene har vi også hatt åpenhet i diskusjonene og gode forventningsavklaringer til hverandre slik at vi unngår misfortåelser. På denne måten oppnår vi god kommunikasjon.  

### 1.2.5 Retrospektiv vurdering av prosjektstruktur
**Vurdering av hva vi har klart til nå:** Fra forrige innlevering og frem til nå er vi godt fornøyde med hvordan vi har brukt Scrum-rammeverket. Vi har gjort oss gode erfaringer på hvordan vi diskuterer ulike valg i gruppen, og spesielt at det har vært hensiktsmessig å diskutere enkelte valg på nytt. En forutsetning for at vi har klart dette er at vi har en prosjektstruktur som fokuserer på møter og dialog mellom gruppemedlemmene. Videre gjør vi oss de samme betraktningene som tidligere om parkoding som bidrar til bedre idémyldring og dermed bedre kodekvalitet. Samarbeid på tvers av roller og samarbeid på spesifikke roller (som testing) har også vist seg å gi god kommunikasjon og gruppedynamikk. Se ellers svar på deloppgavene gitt over, de tilsvarende deloppgavene på tidligere innleveringer og møtereferatene for hvordan vi reflekterer over kommunikasjon og arbeid i gruppen.  

**Hva vi mener kan forbedres:** Når det gjelder hva vi mener kan forbedres relatert til prosjektstruktur viser vi til drøftelesene under [1.2.8 Retrospektiv vurdering av hele prosjektet](#128-retrospektiv-vurdering-av-hele-prosjektet).  

### 1.2.6 Forskjeller i commits
Når det gjelder forskjeller i commits bemerker vi oss det samme som tidligere. Vi har hatt noe forskjeller i commits, og dette skyldes i hovedsak at vi har benyttet oss av parkoding. Dermed er det ofte kun én av to som comitter koden til git. Vi har også fordelt arbeidet slik at noen fokuserer mer på å skrive rapport. På denne måten blir det noen ulikheter i commits.  

### 1.2.7 Forbedring
Når det gjelder forbedringspotensialer viser vi her til svaret på "Hva vi ville gjort annerledes" under [1.2.8 Retrospektiv vurdering av hele prosjektet](#128-retrospektiv-vurdering-av-hele-prosjektet).  

### 1.2.8 Retrospektiv vurdering av hele prosjektet
*For siste innlevering (Oblig 4): Gjør et retrospektiv hvor dere vurderer prosjektet har gått. Hva har dere gjort bra, hva hadde dere gjort annerledes hvis dere begynte på nytt?*  

**Hva har vi gjort bra:** I dette prosjektet er vi fornøyde med valg av prosjektstruktur (Scrum rammeverket). Vi er spesielt fornøyde med at vi startet tidlig på prosjektet og hadde presise avklaringer fra start på hvordan vi ønsket å arbeide. Rollefordelingen har vist seg å være effektiv for framgangen i prosjektet, da dette har fasilitert for spesialisering i de ulike arbeidsoppgaver slik at produktkvaliteten og effektiviteten i arbeidet øker. Vi er også fornøyde med å ha oppnådd god kommunikasjon i gruppen, der alle meninger blir hørt og der alle kommer med konstruktive innspill i de diskusjoner vi har hatt. Dette merker vi har vært en sentral forutsetning for at det ferdige produktet imøtekommer alle krav fra MVP. Vi er også fornøyde med hvordan vi har håndtert problemer som har oppstått underveis, som for eksempel da vi ikke fikk hoppefunksjonen til å fungere optimalt. Gjennom god kommunikasjon og god gruppedynamikk hadde vi løsningsorienterte diskusjoner som førte til at vi kom fram med en løsning vi følte var tilfredsstillende. Videre er vi også fornøyde med vår arbeidsmåte der vi deler opp arbeidet i flere sprinter og plukker stegvis arbeidsoppgaver fra backloggen i vårt Project Board. Dette har bidratt til en jevn og oversiktlig utviklingsprosess. Scrum-rammeverket har også lagt til rette for at vi kan tilpasse prosjektet vårt underveis basert på tilbakemeldinger fra kunden. Dette merker vi også har vært hensiktsmessig, da det har bidratt til at det endelige produktet har blitt bedre. Oppsummert er vi fornøyde med valg av prosjektmetodikk og hvordan det har fasiltert for et effektivt utviklingssamarbeid.  

**Hva vi ville ha gjort annerledes:** Dersom vi hadde startet prosjektet på nytt i dag er det noen endringer vi ville ha gjort. For det første har vi erfart underveis i prosjektet at ved å dele opp sprinter i ulike tidsintervaller oppnår vi en bedre ressursfordeling slik at vi kan ta unna flere arbeidsoppgaver på kortere tid. Dette var en tilpasning vi gjorde oss underveis i prosjektet, men dersom vi hadde gjort dette fra starten ville vi kunne oppnådd en raskere progresjon. 

Videre har vi også gjort oss erfaringer knyttet til hvordan bruke git. I starten av prosjektet redigerte alle koden på samme branch (master branch), og dette førte til at vi stadig opplevde problemer med push og pull av kode. Etter hvert lærte vi hvordan vi kunne dele opp master branch med individuelle brancher for hvert gruppemedlem. På denne måten jobbet hvert gruppemedlem på sin egen branch, og kunne dermed fritt pushe og pulle fra denne branchen uten at det førte til konflikter (merge conflicts). Gjennom prøving og feiling lærte vi oss hvordan vi deretter merget sammen alle de individuelle branchene inn i master branch. Denne erfaringen tar vi med oss videre, og dersom vi hadde startet prosjektet på nytt ville vi valgt å arbeide på individuelle brancher fra start slik at vi ikke opplevde de samme merge konfliktene.  

Når det gjelder vårt Project Board har vi også gjort oss erfaringer om at mer spesifikke arbeidsoppgaver her gjør det enklere å holde oversikt på utviklingen underveis i prosjektet og hva som må gjøres for å fullføre en gitt arbeidsoppgave. Dette er noe vi har lært av og som vi ville vært mer observant på fra start dersom vi hadde startet prosjektet på nytt.  

# 2. Krav
I denne delen av oppgaven vil vi gå gjennom (1) vårt stretch goal for oppgaven og (2) brukerhistorier fra MVP med tilhørende oppfølgingsspørsmål.  

## 2.1 "Stretch goal"
Som stretch goal har vi valgt å fokusere på funksjonalitet for multiplayer. Vi startet på implementasjonen for multiplayer ved forrige innlevering, og har nå implementert den ferdig. Vi fokuserer også på å ha høy kvalitet på koden, godt design og klare abstraksjoner.  

## 2.2 MVP og annet
I denne delen av oppgaven vil vi (1) oppsummere brukerhistoriene og (2) svare på oppfølgingsspørsmål knyttet til brukerhistoriene og kommentere kjente bugs knyttet til dem.  

### 2.2.1 Brukerhistorier
For beskrivelse av hva en brukerhistorie er og hvordan vi har satt dem opp se [innledende kommentar](https://git.app.uib.no/scrumbois/plattform-spill/-/blob/master/Deliverables/ObligatoriskOppgave1.md#32-brukerhistorier) fra første innlevering. Brukerhistoriene her følger samme format, og er oppsummert sammen med akseptansekriterier og arbeidsoppgaver i tabellen under. Etter tabellen følger det også en prioritert liste over hvilke brukerhistorier vi ønsker å ha med i første sprint/iterasjon.  

| Brukerhistorier  | Akseptansekriterier | Arbeidsoppgaver |
|---|---|---|
| **2D spillebrett:** Som spiller ønsker jeg å se et spillebrett, slik at jeg kan orientere meg. | <ul><li>**Krav:** Vise et 2D spillebrett.  </li><li>**Kriterie:** Når programmet kjøres vises et vindu med grafikk til spillebrettet.</li></ul> | For å imøtekomme akseptansekriteriene må klassen *Play* implementeres. Denne klassen implementerer interfacet *Screen*. Videre så vil klassen *Play* sørge for at når koden kjøres så vil et map rendres, sette posisjonen til en spiller (spilleren kommer fra klassen *abstractPlayer*) og sette opp *Orthographic camera* som følger skjermen. |
| **Spiller:** Som utvikler ønsker jeg å kunne bevege spillebrikken i spillet med piltastene og space for å teste funksjonene til spillebrettet og se om disse fungerer slik det skal. | <ul><li>**Krav:** Spilleren må kunne bevege seg.   </li><li>**Kriterie:** Når en piltast trykkes beveges spillebrikken den retningen piltasten peker, og dersom en trykker *space* skal spillebrikken hoppe.</li></ul> | For å imøtekomme akseptansekriteriene må klassen *abstractPlayer* implementeres. Denne klassen utvider den abstrakte klassen *Sprite* fra LibGDX-biblioteket. I klassen *abstractPlayer* vil en spiller opprettes som et objekt av typen *abstractPlayer*. Videre vil feltvariablene *Speed*, *Gravity* og *Velocity* i klassen *abstractPlayer* settes. Disse feltvariablene beskriver hvordan spilleren beveger seg med tanke på hurtighet (*Speed*), tyngdekraft (*Gravity*) og i hvilken retning (*Velocity*). Klassen *abstractPlayer* vil også inneholde en metode *Update* som endrer på posisjonen til spiller-objektet avhengig av verdien på feltvariabelen *Velocity*. *Update* sjekker også om spilleren treffer en celle som er *blocked*, og i så fall vil *Velocity* settes til 0. |
| **Vegger/blokker:** Som utvikler ønsker jeg vegger og blokker slik at jeg kan implementere funksjoner som sørger for at en spiller ikke kan bevege seg gjennom disse objektene. | <ul><li>**Krav:** Spilleren må stoppe når den treffer en vegg eller blokk.  </li><li>**Kriterie:** Når en spiller beveger seg bort mot en vegg eller blokk, kan den ikke passere veggen eller blokken. Spilleren kan imidlertid hoppe over eller på blokken for å passere den.</li></ul> | Her bruker vi *Tiled* for å implementere akseptansekriteriene. Først setter vi egenskapen *blocked* til celle-objektet i det rette tiled-layeret til å være *blocked*. Videre sjekker vi i metoden *Update* fra klassen *abstractPlayer* om spilleren treffer en celle som er blocked. Hvis spilleren treffer en celle som er *blocked* vil feltvariabelen *Velocity* endres til 0. Som konsekvens vil da spilleren stoppe. |
| **Fiender/monstre:** Som spiller ønsker jeg å kunne møte på fiender slik at spillet har utfordringer som gjør det spennende å spille. | <ul><li>**Krav:** Må kunne se en fiende som et objekt på spillebrettet.  </li><li>**Kriterie:** Når spilleren treffer en fiende så mister den liv. Dersom den treffer en fiende mange nok ganger vil den til slutt dø.</li></ul> | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Implementere klassen abstractEnemy. Denne klassen extender klassen abstractPlayer slik at en fiende får de samme egenskapene som player (gravity, collision layer)</li><li>Opprette Enemy-objekter med en tilfeldig posisjon på brettet. Dette skjer samtidig som ny spiller blir opprettet.</li><li>Implementere brukerhistorien *Spiller kan dø* (se under) slik at spilleren mister liv ved kontakt med fiende.</li></ol> |
| **Spiller kan dø:** Som spiller ønsker jeg mulighet til å kunne dø slik at implementasjonen av fiender blir meningsfull. Dette gir da et insentiv til å overkomme fiendene og gjør dermed spillet mer spennende. | <ul><li>**Krav:** Dersom spilleren dør kan den ikke lenger bevege seg i spillet og spillet er dermed over.  </li><li>**Kriterie:** Når spilleren har mistet en gitt mengde med liv skal den være død.</li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Implementere metoden isAttacked. Denne metoden vil kalle på funksjonen getAttack når spilleren blir angrepet.</li><li>Implementere getAttack: Denne funksjonen vil enten sette ned liv på spiller eller forlytte spilleren, avhengig av om fienden er en bombe eller en fiende som dreper/setter ned liv.</li><li>Implementere metoden Attack: Denne metoden iterer over alle fiender og sjekker om spiller kolliderer med en fiende fra toppen eller fra siden.</li><li>Implementere metodene collidesWithActorFromTop og collidesWithActorFromSide i klassen Item som skal brukes i Attack.</li><li>Implementere metoden inBounds som sjekker om spiller faller ut av mappet, og i så fall la spilleren miste liv slik at den dør.</li></ol> |
| **Liv:** Som spiller ønsker jeg å å kunne plukke opp liv slik at jeg kan helbrede meg selv etter å ha truffet på en fiende, og på denne måten unngå å dø. | <ul><li>**Krav:** Objekter som gir spilleren liv må være plassert på spillebrettet.  </li><li>**Kriterie:** Når spilleren går bort til et liv-objekt kan den plukke opp pakken med liv ved å trykke på "F" slik at liv til spilleren øker.</li></ul> | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Implementere PickUpItem-funksjonen som (1) sjekker at spiller er på item, (2) sjekker om item er av typen *medkit* (liv) og (3) kaller på setHealth()-funksjonen.</li><li>Implementere klassen Medkits som extender Item-klassen. Denne klassen oppretter liv-objekter.</li><li>Implementere GetAmount()-funksjonen i Medkits som henter feltvariabelen som indikerer verdien til liv-objektet.</li><li>Implementere setHealth()-funksjonen som øker liv med den gitte mengden som liv-objektet har.</li></ol> |
| **Spiller kan bli flyttet på av fiende:** Som spiller ønsker jeg å bli ufrivillig flyttet på spillebrettet når jeg treffer en fiende (bombe) slik at spillet blir mer utfordrene å spille. | <ul><li>**Krav:** Et fiende-objekt (bombe) må kunne flytte spilleren ved kontakt.  </li><li>**Kriterie:** Spilleren blir flyttet bortover spillebrettet uten at spilleren kan påvirke forflytningen.</li></ul> | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Implementere klassen Bombs som extender klassen abstractEnemy. Her defineres det som er spesielt for bombs-objektet, som f.eks type angrep.</li><li>Kalle på getAttack-funksjonen som deretter vil endre på *velocity* til spilleren slik at den flyttes på.</li></ol> |
| **Nøkkel:** Som spiller ønsker jeg å kunne plukke opp en nøkkel når jeg beveger meg gjennom spillebrettet slik at spillet blir utfordrene og har et mål ved seg (plukke opp nøkkel og gå i mål). Nøkkelen kreves for å vinne spillet. | <ul><li>**Krav:** Spiller må ha plukket opp nøkkel <ins>før</ins> spilleren går i mål-området for å kunne vinne spillet.</li><li>**Kriterie:** Det må finnes en nøkkel på spillebrettet, og spilleren må ha mulighet til å plukke opp denne nøkkelen.</li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Implementere klassen *Key* som extender klassen *Item*. I klassen *Key* spesifiseres hva som er spesifikt for et Nøkkel-objekt, nemlig størrelse og navn.</li><li>Implementere funksjonen *getKey* i klassen *ItemFactory* som genererer nye nøkler og plasser dem på spillebrettet.</li><li>Kalle på *getKey()*-funksjonen inne i *show()*-funksjonen i klassen Play, slik at nye Nøkkel-objekter bli initialisert og plassert på spillebrettet når nytt spillebrett lastes inn.</li></ol> |
| **Meny-skjerm:** Som spiller ønsker jeg å kunne se en start-skjerm med en meny når jeg starter spillet slik at jeg kan velge om jeg skal (1) starte spillet med én spiller (Play), eller om jeg (2) skal starte spillet med multiplayer eller (3) om jeg ønsker å avslutte spillet (Exit).  | <ul><li>**Krav:** En meny med ulike valgalternativer må komme opp på skjermen når spillet startes (kjører filen *Main*). </li><li>**Kriterie:** Spilleren må kunne et alternativ fra menyen. </li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Implementere klassen *MenuScreen* som extender klassen *Game* og implementerer klassen *Screen*. Denne klassen vil lage en ny meny-skjerm når spillet startes, bestående av en bakgrunn, knapper for å starte spill en eller to spillere (Multiplayer) og knapp for exit. Her legger vi også til bakgrunnsmusikk til meny-skjermen.</li><li>Opprette et nytt *MenuScreen*-objekt i klassen *app* og sette dette som første skjerm som kommer opp når spillet startes</li></ol> |
| **Poeng:** Som spiller ønsker jeg å ha mulighet til å få poeng når jeg spiller slik at jeg kan sammenlikne min egen prestasjon mot tidligere spill av meg selv eller andre. På denne måten kan jeg som spiller måle om jeg har blitt flinkere i spillet. | <ul><li>**Krav:** Gjenstander som gir poeng må være plassert på spillebrettet. I vårt spill har vi valgt at fiender/monstre skal være gjenstander som gir poeng når spilleren dreper disse (hopper på de). </li><li>**Kriterie:** Spiller må ha mulighet til å interagere med gjenstandene som gir poeng, altså å hoppe på fienden slik at den dør. Videre må antall poeng for spilleren må oppdateres når spilleren interagerer med gjenstanden som gir poeng (hopper på fienden). </li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Legge til feltvariabelen *killStreak* på hvert spillerobjekt i klassen *mainPlayer*</li><li>Oppdatere feltvariabelen *killStreak* i funksjonen *attack()* dersom spilleren dreper en fiende.</li></ol> |
| **Lyd:** Som spiller ønsker jeg å kunne høre lyd når jeg spiller slik at det blir mer spennende og interessant å spille. | <ul><li>**Krav:** Det må være mulig å høre lyder fra spillet når spillet kjøres.</li><li>**Kriterie:** Det må være ulike lyder for ulike deler av spillet som tilfører en mening/verdi til spilleren. Dette gjelder for eksempel egen bakgrunnslyd for meny-skjerm, egen bakgrunnslyd for første spillebrett, andre spillebrett osv. I tillegg må det også være lydeffekter når spilleren hopper.</li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Bruke libGDX-biblioteket til å legge inn lyd i klassen *MenuScreen* som feltvariabel til et *MenuScreen*-objekt</li><li>Bruke det samme libGDX-biblioteket til å legge inn lyder på andre objekter slik som *Key*.</li></ol> |
| **Game Over-skjerm:** Som spiller ønsker jeg å se en skjerm som viser "Game Over" når jeg dør i spillet slik at det blir tydelig for spilleren at spillet er over. | <ul><li>**Krav:** En egen skjerm som viser "Game Over" må vises når spilleren dør.</li><li>**Kriterie:** Game Over-skjermen vises når spilleren har mistet alt liv og dermed er død.</li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li>Implementere klassen *GameOverScreen* som oppretter et nytt objekt som brukes når spilleren har mistet alt liv.</li><li>Kalle på *GameOver* objektet i *update()*-funksjonen i klassen *mainPlayer*.</li></ol> |
| **Flere levels/maps:** Som spiller ønsker jeg å ha flere ulike levels/maps når jeg spiller spillet slik at spillet blir mer spennende å spille ved at det er mer å utforske på spillet. | <ul><li>**Krav:** Spilleren må bli ferdig med det første levelet før spilleren kan gå inn i det andre levelet. </li><li>**Kriterie:** Det må finnes flere levels/maps i spillet slik at spilleren kan komme seg til senere levels. </li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li> Legge til feltvariabelen *currentLevel* i klassen *mainPlayer*</li><li> Oppdatere feltvaraibelen *currentLevel* i funksjonen *nextLevel()* dersom spilleren er ferdig med det første levelet. </li><ol> |
| **Multiplayer:** Som spiller ønsker jeg å kunne spille med to spillere slik at jeg kan spille sammen med andre. På denne måten blir spillet mer interessant for meg som spiller da det blir mer inkluderende. | <ul><li>**Krav:** Når spillet startes må spilleren kunne velge Multiplayer i stedet for Single Player. </li><li>**Kriterie:** Det må komme opp to ulike spillere på spillebrettet når Multiplayer velges, og hver enkelt spiller må ha sine egne kontrollere slik at to personer kan spille spillet samtidig og styre hver sin spiller uavhengig av den andre. </li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li> Implementere mulighet for Multiplayer i funksjonen *show()* i klassen *Play*. </li><li> Legge inn kontrollere for Player 2 i funksjonen *keyDown* i klassen *controller*. </li></ol> |
| **Scoreboard:** Som spiller ønsker jeg å kunne se et scoreboard når jeg dør eller vinner spillet slik at jeg kan vurdere min egen prestasjon mot tidligere prestasjoner av spillere. Dette gjør spillet mer interessant da det gir meg et insentiv til å spille mer for å oppnå best mulig score på scoreboardet. | <ul><li>**Krav:** Når spilleren dør eller vinner spillet må det komme opp et scoreboard på skjermen over de beste poengescorene. Altså en nummerert liste på de beste poengscorene. </li><li>**Kriterie:** Spilleren må ha startet spillet og enten ha dødd eller vunnet spillet for at scoreboard skal bli synlig. </li></ul> | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li> Opprette klassen *ScoreDB* som skal inneholde funksjonaliteter for poengscore. </li><li> Opprette funksjonene *create()*, *getTopTen()*, *write()* og *read()* som sammen sørger for å lage toppscore, lagre den, lese den inn og vise den fram på spillebrettet når spilleren dør eller vinner spillet. </li></ol> |
| **Wizard (fiende):** Som spiller ønsker jeg å ... når jeg ... slik at ... | <ul><li>**Krav:**  </li><li>**Kriterie:**  </li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li> ... </li><li> ... </li><li> ... </li></ol> |
| **Brukerhistorie:** Som spiller ønsker jeg å ... når jeg ... slik at ... | <ul><li>**Krav:**  </li><li>**Kriterie:**  </li></ul>  | Liste på funksjonaliteter som må implementeres for å imøtekomme akseptansekriteriene: <ol type="1"><li> ... </li><li> ... </li><li> ... </li></ol> |

### 2.2.2 Oppfølgingsspørsmål brukerhistorier
**Prioritert liste på krav:**  
1. Multiplayer  
2. Flere level/maps 
3. Game-Over skjerm 
3. Scoreboard
4. Wizard

**Hvor langt vi har kommet og hva vi har gjort siden forrige gang:** Når det gjelder meny-skjermen har vi lagt til valgmulighet for Multiplayer da denne funksjonaliteten er ferdig implementert. Game-Over skjerm er også ferdig implementert. Dette var en brukerhistorie vi startet på ved forrige innlevering og har fullført nå. Det samme gjelder også Multiplayer. De øvrige brukerhistoriene Flere level/maps, Scoreboard og Wizard på listen over er også ferdig implementert.  

**Hvordan ny funksjonalitet prioriteres:** Ikke relevant da prosjektet er ferdig. Vi er imidlertid fornøyde med vår endelige leveranse og det er ikke flere funksjonaliteter vi ønsker å legge til.   

**Hvordan oppgavene fremover blir prioritert:** Ikke relevant da vi er ferdige med prosjektet.   

**Endringer i rekkefølge på MVP utfra det som er gitt fra kunde:** Ikke relevant da vi er ferdige med prosjektet og da alle krav fra MVP er implementert.  

**Bugs i koden/kravene som er utført:**  


# 3. Produkt og kode

## 3.1 Utbedring av feil 
**Feil fikset fra forrige innlevering:**   
 - Fikset resize av vinduet. Nå er det ikke lenger mulig å resize vinduet, og dermed blir det heller ikke problemer med knappene på meny-skjermen.  

## 3.2 Tester
For testing av funksjonalitetene i koden se eget dokument [her](https://git.app.uib.no/scrumbois/plattform-spill/-/blob/master/Deliverables/ManuelleTester.md).  

## 3.3 Annet
**Dokumentasjon om teknisk produktoppsett (hvordan bygge og kjøre programmet):** For å kjøre dette spillet trenger du først å laste ned en IDE (Integrated Development Environment) på din datamaskin og installere programvaren. En IDE er en programvare for å skrive og lage annen programvare, og det er her du kan kjøre koden for spillet som vi har laget. Noen av de mest populære IDE'ene å bruke er for eksempel [IntelliJ](https://www.jetbrains.com/idea/download/#section=mac) eller [VSCode](https://code.visualstudio.com/download). Husk å laste ned riktig versjon basert på om du bruker Mac, Windows eller Linux. Etter at du har lastet ned programvaren og installert den på din datamaskin gjenstår det å åpne filkoden til spillet og kjøre programmet. For å åpne filkoden må du først starte din IDE, deretter gå til "File" -> "Open" og deretter navigere deg fram til mappen som inneholder koden til spillet. Deretter markerer du denne mappen og trykker på "Open". Du skal nå kunne se hele koden til spillet i din IDE, med mulighet til å bla gjennom de ulike klassene i menyen til venstre. For å kjøre koden må du kjøre filen som heter *Main*. Denne ligger i package *inf112.skeleton.app*. For å kjøre *Main* kan du høyre-klikke på filen i menyen til venstre og velge *Run 'Main.main()'*. Dersom du har gjort dette riktig skal det komme opp et nytt vindu der spillet starter. Du kan nå spille spillet ved å bevege spilleren med piltastene eller WASD og bruke space for å hoppe. Pass på å ikke gå inn i fiendene, men hopp heller oppå de for å drepe dem.  

**Nåværende Prjoct Board:**  
![alt text](/assets/maps/trello4.png)  

**Klassediagram:**  
![alt text](/assets/maps/classDiagram.png)  



